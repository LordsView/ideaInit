
1.ArrayList
/**
*     List接口的可调整数组实现。实现所有可选的列表操作，并允许所有元素，包括null。除了实现List接口之外，
* 该类还提供了一些方法来操作内部用于存储列表的数组的大小。(这个类大致相当于Vector，只是它是非同步的。) size、isEmpty、get、set、iterator和listIterator操作在恒定时间内运行。
* 加法运算在平摊常数时间内运行，也就是说，加n个元素需要O(n)时间。所有其他操作都在线性时间内运行(粗略地说)。与LinkedList实现相比，常量系数较低。
*    每个ArrayList实例都有一个容量。容量是用于存储列表中元素的数组的大小。它总是至少与列表大小一样大。随着元素被添加到数组列表中，它的容量会自动增长。
* 除了添加一个元素具有恒定的平摊时间成本之外，没有指定增长策略的细节。 应用程序可以在添加大量元素之前使用ensureCapacity操作增加ArrayList实例的容量。
* 这可能会减少增量再分配的数量。
*    注意，这个实现不是同步的。如果多个线程并发访问一个ArrayList实例，并且至少有一个线程在结构上修改了该列表，那么它必须在外部同步。
* (结构修改是添加或删除一个或多个元素，或显式调整支持数组的大小的任何操作;仅仅设置元素的值并不是结构修改。)这通常是通过在自然封装列表的某些对象上同步来实现的。
* 如果不存在这样的对象，则应该使用集合“包装”列表。synchronizedList方法。这最好在创建时完成，以防止意外的不同步访问列表: 列表列表=集合。synchronizedList(新ArrayList(…));
* 这个类的迭代器和listIterator方法返回的迭代器是快速失败的:如果在迭代器创建后的任何时候，以除了迭代器自己的remove或add方法以外的任何方式对列表进行了结构修改，
* 迭代器将抛出ConcurrentModificationException异常。因此，在面对并发修改时，迭代器会快速而干净地失败，而不是在未来不确定的时间发生任意的、不确定的行为。
*   注意，迭代器的快速失败行为不能得到保证，因为一般来说，在存在不同步的并发修改时，不可能做出任何硬保证。快速失败迭代器尽可能地抛出ConcurrentModificationException。
* 因此，编写一个依赖于此异常的程序是错误的:迭代器的快速失败行为应该只用于检测错误。 这个类是Java集合框架的成员。
*
* tips: 无参构造函数默认为初始化容量为0，第一次调用add方法，初始化容量为10
*
*/
1.1 method
1.1.1 add(E e) : 容量检查(elementData为{}初始化容量为10,size+1>elementData.length时扩容(size初始化为0),大概扩容为原来的1.5倍(原来容量+原来容量右移一位,原来容量为偶数，扩容1.5倍，为奇数则实际小于1.5倍))->容量检查后给数组元素赋值elementData[size++]=e
1.2.2 remove(int index) : 范围检查(index>size?),大于则抛出数组下标越界异常->列表修改次数加1(modCount++)->判断移除元素是否为最后一个元素,是则执行最后一步->不是则分段复制左移数组System.arraycopy(elementData(源数组), index+1(要复制的源数组开始下标), elementData(目标数组), index(目标数组复制开始位置),
                                                                                                                                        numMoved(复制长度(size-index-1)));->最后设置数组最后一个元素为null:elementData[--size] = null;
1.2.3 retainAll(Collection<?> c) 取交集
例如A.retainAll(B);
如果AB中有相同的元素，那么A中会保留相同的元素，将不同的元素移除
如果AB中没有相同的元素，那么会返回[]
当A中的元素有变化时会返回true，没有变化会返回false


1.2 线程安全list
1.2.1、Vector
这个是最常听到的线程安全的List实现，但是已经不常用了。
内部实现直接使用synchronized 关键字对 一些操作的方法加锁。性能很慢。
1.2.2、SynchronizedList
使用Collections.synchronizedList(list); 将list包装成SynchronizedList
需要注意的是SynchronizedList的add等操作加了锁，但是iterator()方法没有加锁，如果使用迭代器遍历的时候需要在外面手动加锁。
适用场景：当不需要使用iterator()并且对性能要求不高的场景。

SynchronizedList 和 Vector区别
1> SynchronizedList 有较好的扩展性，可以将ArrayList ，LinkedList等都改成同步的，而Vector底层只有数组的结构。
2> SynchronizedList 并没有对Iterator方法进行加锁，遍历时需要手动同步处理，Vector加锁了。
3> SynchronizedList 可以指定锁定的对象。
4> 扩容机制不一样SynchronizedList 1.5倍 ，Vector 2倍。
5、SynchronizedList使用同步代码块，锁的范围更小。Vector锁的方法。

1.2.3、CopyOnWriteArrayList
在写的时候加锁（ReentrantLock锁），读的时候不加锁，大大提升了读的速度。
添加元素的时候，先加锁，再复制替换操作，再释放锁。

    public boolean add(E e) {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            Object[] elements = getArray();
            int len = elements.length;
            Object[] newElements = Arrays.copyOf(elements, len + 1);
            newElements[len] = e;
            setArray(newElements);
            return true;
        } finally {
            lock.unlock();
        }
    }

 2.LinkedList
/**
* 双链表实现的list和Deque接口。实现所有可选的列表操作，并允许所有元素(包括null)。 所有的操作都按照双链表的预期执行。索引到列表中的操作将从列表的开始或结束遍历列表，以更接近指定索引的为准。
* 注意，这个实现不是同步的。如果多个线程并发访问一个链表，并且其中至少有一个线程在结构上修改了链表，那么它必须在外部同步。(结构修改是添加或删除一个或多个元素的任何操作;仅仅设置元素的值并不是结构修改。)这通常是通过在自然封装列表的某些对象上同步来实现的。
* 如果不存在这样的对象，则应该使用集合“包装”列表。synchronizedList方法。这最好在创建时完成，以防止意外的不同步访问列表: 列表列表=集合。synchronizedList(新LinkedList(…));
* 这个类的迭代器和listIterator方法返回的迭代器是快速失败的:如果在迭代器创建后的任何时候，以除迭代器自己的remove或add方法以外的任何方式对列表进行了结构修改，迭代器将抛出ConcurrentModificationException异常。
* 因此，在面对并发修改时，迭代器会快速而干净地失败，而不是在未来不确定的时间发生任意的、不确定的行为。 注意，迭代器的快速失败行为不能得到保证，因为一般来说，在存在不同步的并发修改时，不可能做出任何硬保证。快速失败迭代器尽可能地抛出ConcurrentModificationException。
* 因此，编写一个依赖于此异常的程序是错误的:迭代器的快速失败行为应该只用于检测错误。 这个类是Java集合框架的成员。
*/

3.HashMap
/**
* 基于哈希表的Map接口实现。该实现提供了所有可选的映射操作，并允许空值和空键。(HashMap类大致相当于Hashtable，除了它是非同步的，并且允许为空值。)这个类不保证映射的顺序;
* 特别是，它不能保证顺序随时间的推移保持不变。 这个实现为基本操作(get和put)提供了恒定时间的性能，假设哈希函数将元素适当地分散到桶中。
* 在集合视图上迭代所需的时间与HashMap实例的“容量”(桶的数量)加上它的大小(键-值映射的数量)成正比。
* 因此，如果迭代性能很重要，就不要将初始容量设置得太高(或负载因子设置得太低)。 HashMap实例有两个影响其性能的参数:初始容量和负载因子。
* 容量是哈希表中桶的数量，初始容量是创建哈希表时的容量。负载系数衡量的是在哈希表的容量自动增加之前允许达到的满度。
* 当哈希表中的条目数超过负载因子和当前容量的乘积时，哈希表将被重新哈希(即重新构建内部数据结构)，以便哈希表的桶数约为原来的两倍。
* 作为一般规则，默认负载系数(.75)在时间和空间成本之间提供了很好的权衡。较高的值会减少空间开销，但会增加查找成本(反映在HashMap类的大多数操作中，包括get和put)。
* 在设置映射的初始容量时，应考虑映射中期望的条目数及其负载因子，以减少重哈希操作的次数。如果初始容量大于最大条目数除以负载因数，则不会发生重哈希操作。
* 如果要将许多映射存储在一个HashMap实例中，那么用足够大的容量创建它将允许更有效地存储映射，而不是让它根据需要执行自动重哈希以增长表。注意，在同一个hashCode()中使用多个键肯定会降低任何哈希表的性能。
* 为了改善影响，当键具有可比性时，该类可以使用键之间的比较顺序来帮助打破束缚。 注意，这个实现不是同步的。如果多个线程并发访问一个哈希映射，并且至少有一个线程在结构上修改了映射，那么它必须从外部同步。
* (结构修改是添加或删除一个或多个映射的任何操作;仅仅改变与实例中已经包含的键相关联的值并不是结构修改。)这通常是通过在自然封装映射的某些对象上同步来实现的。
* 如果不存在这样的对象，则应该使用集合“包装”映射。synchronizedMap方法。这最好在创建时完成，以防止意外的不同步访问映射: 映射m =集合。synchronizedMap(新HashMap(…));
* 这个类的所有“集合视图方法”返回的迭代器都是快速失败的:如果映射在迭代器创建后的任何时间被结构修改，除了通过迭代器自己的remove方法以外，迭代器将抛出ConcurrentModificationException。
* 因此，在面对并发修改时，迭代器会快速而干净地失败，而不是在未来不确定的时间发生任意的、不确定的行为。 注意，迭代器的快速失败行为不能得到保证，因为一般来说，在存在不同步的并发修改时，不可能做出任何硬保证。
* 快速失败迭代器尽可能地抛出ConcurrentModificationException。因此，编写一个依赖于此异常的程序是错误的:迭代器的快速失败行为应该只用于检测错误。 这个类是Java集合框架的成员。
*/